Building your own DDS **Hello World!**
======================================

To test the complete workflow of building a DDS-based application, you
can use the simple **Hello World!** but now build it yourself instead.
Although this application does not reveal all the power of building a
data-centric application, it has the merit of introducing you to the basic
steps to create a DDS application.

First we will focus on building this example without analyzing the source code.
Next, we will analyze the source code to see what makes it tick.

The procedure used to build the **Hello World!** example can also be used
for building your own applications.

Start by copying ``examples/helloworld`` to a new workspace and open a terminal
in that directory. Six files are available under the **Hello* *World!** root directory to
support building the example. For this chapter, we mainly describe:

-  ``CMakeLists.txt``
-  ``HelloWorldData.idl``
-  ``publisher.c``
-  ``subscriber.c``

Building the **Hello World!** application with CMake
----------------------------------------------------

In the previous sections, building the **Hello World!** example is done
by default during the |var-project-short| build process. However, the **Hello World!** example
can also be built on its own. We do this, again, using the CMake build tool.

.. note:: CMake

    `CMake <http://cmake.org/>`__ is an open-source, cross-platform family
    of tools designed to build, test, and package software. It controls
    the software compilation process using simple platform and
    compiler-independent configuration files. It also generates native
    makefiles, projects, and workspaces of your development environment.
    CMake's main strength is built portability. The same CMake input files
    build with GNU make, Visual Studio 6,7,8 IDEs, Borland make, nmake, and
    XCode, etc...

    Another advantage of CMake is building out-of-source. It simply works
    out of the box. This facilitates:

     -  Easy cleanup (no cluttering the source tree). Remove the build
        directory to start from scratch.
     -  Multiple build targets. It's possible to have up-to-date Debug and
        Release targets without having to recompile the entire tree. It is easy for
        systems that do the cross-platform compilation to have
        up-to-date builds for the host and target platform.

To use CMake, you need to provide a ``CMakeLists.txt``. We will use the ``CMakeLists.txt``
that comes with the **Hello World!** example. The content is shown below:

The content of the ``CMakeLists.txt`` is:

.. literalinclude:: ../../../../examples/helloworld/CMakeLists.txt
   :language: cmake
   :linenos:

To build a |var-project-short| based application, you need to link your business code with:

 -  The ``ddsc`` library that contains the DDS API the application needs.

 -  The helper functions and structures that represent your datatypes.
    These helpers are generated by the IDL compiler and can
    be accessed through the CMake (``idlc_generate``) call that takes the
    idl file (e.g ``HelloWorld.idl``) as input and packages the datatyped
    helpers in a library (e.g. ``HelloWorldData_lib``).

The ``idlc_generate`` call makes use of how the IDL compiler
generates the helpers' functions and structures. This process is depicted below.

.. image:: /_static/gettingstarted-figures/dds-application-design.png
   :align: center

The executables of the |var-project-short|-based application (in this case ``HelloworldPublisher``
and ``HelloworldSubscriber``) are linked to |var-project-short| with the CMake ``target_link_libraries()``
call. This call combines the ``ddsc`` lib, the datatype helper lib and the application code.

.. note::

    CMake attempts to find the ``CycloneDDS`` CMake package in the default system locations.
    If you experience problems with not being able to locate ``CycloneDDS`` it is often enough to include the |var-project-short| <install-location> as
    CMake Prefix Path like so: ``cmake -DCMAKE_PREFIX_PATH=<install-location>``. If you have further issues, please
    consult CMake's `Using dependencies guide <https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#guide:Using%20Dependencies%20Guide>`__.


Building the **Hello World!** Example
-------------------------------------

With our ``CMakeLists.txt`` file in hand we can now start the build process.
It's good practice to build examples or applications out-of-source by creating a ``build`` directory inside
where you copied the **Hello World!** example. In the terminal that you opened inside the directory with
the **Hello World!** files run:

.. code-block:: bash

    mkdir build
    cd build

Now you can configure the build environment:

.. tabs::

    .. group-tab:: Linux

        .. code-block:: bash

            cmake -DCMAKE_PREFIX_PATH=<install-location> ..

    .. group-tab:: macOS

        .. code-block:: bash

            cmake -DCMAKE_PREFIX_PATH=<install-location> ..

    .. group-tab:: Windows

        .. code-block:: bash

            cmake -G <generator-name> -DCMAKE_PREFIX_PATH=<install-location> ..

        On Windows you can build with one of several generators. Usually if you omit the ``-G <generator-name>``
        it will pick a sensible default, but if it doesn't work or picks something unexpected you can go to the
        `CMake generators documentation <https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html>`__.
        For example, "Visual Studio 15 2017 Win64" targets a 64-bit build using Visual Studio 2017.

        .. warning::

            If manually specifying generators be careful about mixing and matching! If you compiled |var-project-short| with 32-bit libraries
            and you try to compile **Hello World!** as 64-bit or vice-versa it will not work.

        .. warning::

            Weird things can happen if you mix ``-DCMAKE_BUILD_TYPE=Release``, ``-DCMAKE_BUILD_TYPE=RelWithDebInfo`` and ``-DCMAKE_BUILD_TYPE=Debug``,
            try to match what you picked for |var-project-short| in downstream projects.


CMake uses the CMakeLists.txt in the HelloWorld directory to create "makefiles" that target the native platform.
Our build directory is now prepared to build the actual executables (``HelloworldPublisher`` and ``HelloworldSubscriber`` in this case):

.. code-block:: bash

    cmake --build .

Your build directory should now contain your executables (on Windows they might be in a ``Release`` or ``Debug`` subdirectory). You can
execute them in the same way as described in the `Test your installation <#test-your-installation>`__ section.
